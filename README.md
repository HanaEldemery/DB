# Fully Functional Database Engine with support for B+ tree index and Paging using Java
I developed a fully functional Database Engine in Java with support for B+ tree index that supports fundamental Database operations like creating tables, creating indices, inserting tuples, updating tuples, deleting tuples and selecting tuples. 
I also needed to take into account the efficiency of the program so that it can handle large volumes of data, ensuring that efficient searching algorithms were used in order to look for and retrieve needed data, utilizing indices created or otherwise using binary search whenever possible.
The Database Engine also supports Paging, as well as B+ Tree Indices that can be created on any column. This index can be later used in the lookup algorithms to make the process of data retrieval faster.
I created the necessary directory structure for the project, including a resources directory within the project source, where I placed a configuration file named DBApp.config. This file contained a key-value pair specifying an essential parameter, the maximum number of rows per page.
I proceeded to implement the core functionalities of the database engine. I developed the DBApp.java class, which included the required methods for initializing the application, creating tables, inserting and updating tuples, deleting tuples, and searching in tables. For table creation, I ensured that each table/relation was stored as pages on disk, with a fixed maximum number of rows per page. No page was loaded from disk into memory unless it contained the data I needed, making my Engine operate faster. I used Javaâ€™s binary object files to emulate pages, storing tuples as serialized Vectors of objects.
I implemented methods to handle the insertion of tuples, ensuring that if a page was full, tuples would be shifted to the following page. I also developed functionality to postpone the loading of pages until needed, thereby optimizing memory usage. For deletion, I ensured that pages were deleted when all rows were removed, avoiding the retention of empty pages. I also supported defragmentation of data when tuples were deleted.
In terms of metadata management, I created a metadata.csv file to store information about the tables, such as column names, data types, and indices. This file was utilized to verify data types during operations, ensuring data integrity. I also implemented methods to create and manage B+ tree indices, using open-source B+ tree implementations to support efficient searching, updating and deleting of indexed columns.
Additionally, I ensured that indices were updated correctly during insertions, updates and deletions. I saved indices to disk and loaded them upon application startup to avoid scanning entire tables to rebuild indices. I also implemented methods to use indices for query execution where possible, falling back on binary search when necessary.
I also supported loading data types dynamically where applicable. This approach allowed the system to determine the specific type of data (e.g., Integer, String, Double) for each column dynamically, based on the information stored in the metadata file (metadata.csv). I was able to create instances of these data types, invoke their methods, and manage them in a more flexible and generic manner without hardcoding type-specific logic. Finally, I tested the implementation thoroughly to ensure all functionalities, including table creation, tuple insertion, updating, deletion, and searching, were working as expected, both with and without indices. This comprehensive approach ensured that the mini database engine met the project requirements and performed efficiently, improving my understand of what happen below the hood of Database Engines drastically.
